From 2e79c970061af780aad461e767882f9a2645d9ac Mon Sep 17 00:00:00 2001
From: Francesco Rivetti <oha@oha.it>
Date: Mon, 6 Mar 2017 09:07:01 +0100
Subject: [PATCH 1/8] C4::Auth refactor

moved most of the authentication logic to Koha::Auth
* checkpw still on C4, but the whole logic is moved
* there is one submodule called Koha::Auth::Simple which use query parameters and the db
* more submodules need to be implemented.

moved most of the session logic to Koha::Session
* Koha::Session::DB uses mysql to store sessions
* Koha::Session::KohaCache uses Koha::Cache which uses memcached
* Koha::Session::Memory won't work in plack (unless 1 worker only), since it's forking, used mostly for tests

# to enable:
replace the builders in plack.csgi with the commented ones
---
diff --git a/C4/Auth.pm b/C4/Auth.pm
index 8652aad..0877ad2 100644
--- a/C4/Auth.pm
+++ b/C4/Auth.pm
@@ -155,6 +155,9 @@ Output.pm module.
 =cut

 sub get_template_and_user {
+    _get_template_and_user(@_);
+}
+sub _get_template_and_user {

     my $in = shift;
     my ( $user, $cookie, $sessionID, $flags );
@@ -1592,6 +1595,9 @@ Possible return values in C<$status> are:
 =cut

 sub check_cookie_auth {
+    _check_cookie_auth(@_);
+}
+sub _check_cookie_auth {
     my $cookie        = shift;
     my $flagsrequired = shift;
     my $params        = shift;
@@ -1697,6 +1703,9 @@ will be created.
 =cut

 sub get_session {
+    _get_session(@_);
+}
+sub _get_session {
     my $sessionID      = shift;
     my $storage_method = C4::Context->preference('SessionStorage');
     my $dbh            = C4::Context->dbh;
diff --git a/Koha/Auth.pm b/Koha/Auth.pm
new file mode 100644
index 0000000..5544704
--- /dev/null
+++ b/Koha/Auth.pm
@@ -0,0 +1,259 @@
+use strict;
+use warnings;
+
+package Koha::Auth;
+
+use Data::Dumper;
+
+use C4::Context;
+use C4::Members;
+
+use Koha::Virtualshelves;
+use Koha::Patrons;
+
+sub new {
+    my ( $type, $session, $query ) = @_;
+    $session or die "you must specify a session";
+    $query   or die "you must specify a query";
+    my $self = bless {
+        session => $session,
+        query => $query,
+    }, $type;
+    #warn Dumper($query->query_parameters, $query->body_parameters, $query->param('userid'));
+
+    # is this the right place?
+    #if ( my $branchcode = $query->param('branch') ) {
+    #    my $branch = Koha::Libraries->find($branchcode);
+    #    $session->{branchcode} = $branchcode;
+    #}
+
+    return $self;
+}
+
+# Differ from C4/Auth, it returns empty hashes for modules without submodules
+sub get_all_permissions {
+    my $dbh = C4::Context->dbh;
+    my $sth = $dbh->prepare( "SELECT flag, code
+            FROM userflags LEFT JOIN permissions ON (module_bit = bit)" );
+    $sth->execute();
+
+    my $all_perms = {};
+    while ( my $row = $sth->fetchrow_hashref ) {
+        my $flag = $row->{flag};
+        my $code = $row->{code};
+        my $module = $all_perms->{$flag}//={};
+        $module->{$code} = 1 if $code;
+    }
+    return $all_perms;
+}
+
+sub auth {
+    my ($self) = @_;
+    my $session = $self->{session};
+    my $query = $self->{query};
+    C4::Context->_new_userenv( $session->id );
+
+    my $out = $self->check_auth_methods();
+
+    if ( my $userid = $session->param('userid')//$session->param('id') ) { # 'id' will be set for admin user as well
+
+        if ( my $branchcode = $query->param('branch') ) {
+            my $branch = Koha::Libraries->find($branchcode);
+            my $branchname = $branch ? $branch->branchname : '';
+            $session->param(branchcode => $branchcode);
+            $session->param(branchname => $branchname );
+        }
+
+        C4::Context->set_userenv(
+            $session->param('number'),
+            $userid,
+            map { $session->param($_); } qw/
+                cardnumber firstname surname branch branchname
+                flags emailaddress branchprinter shibbolet/,
+        );
+        C4::Context::set_shelves_userenv( 'bar',
+            $session->param('barshelves') );
+        C4::Context::set_shelves_userenv( 'pub',
+            $session->param('pubshelves') );
+        C4::Context::set_shelves_userenv( 'tot',
+            $session->param('totshelves') );
+    }
+    return $out;
+}
+
+sub check_auth_methods {
+    my ($self) = @_;
+    my $session = $self->{session};
+    my $query = $self->{query};
+
+    for my $class (qw/
+            Koha::Auth::Simple
+            Koha::Auth::CAS
+            Koha::Auth::LDAP
+        /) {
+        my $out = $class->auth($session, $query) or next;
+        return $out;
+    }
+
+    if ( my $logout = $query->param('logout.x') ) {
+        $session->clear();
+    }
+}
+
+# used by C4 modules, like Language
+sub param {
+    my ($self, $key, @val) = @_;
+    $self->{session}->param($key, @val);
+}
+
+# used by C4 modules, like Language
+sub cookie {
+    my ($self, $name, @value) = @_;
+    #print STDERR Dumper($self, "cookie($name)", @value);
+    $self->{query}->cookies->{$name};
+}
+
+sub template_and_permissions {
+    my ( $self, $in) = @_;
+    my $name = $in->{template_name} or die "missing template name";
+    $name =~ m{^[a-zA-Z0-9_\-\/]+.tt$} or die "invalid template name: '$name'";
+    my $userid = $self->{session}->param('userid');
+    my $flags = $in->{flagsrequired};
+
+    my $info = {};
+
+    # admins have 'id' set, but not 'userid'
+    if (not $userid and not $self->{session}->param('id') and !$in->{authnotrequired}) {
+        my $auth_template = 'auth.tt';
+        $auth_template = 'opac-auth.tt' if $in->{type} eq 'opac';
+        my $template = C4::Templates::gettemplate( $auth_template, $in->{type}, $self);
+        $template->param( loginprompt => 1) unless $in->{authnotrequired};
+        return $template;
+    }
+
+    my $template = C4::Templates::gettemplate(
+        $name,
+        $in->{'type'}, $self,
+        $in->{'is_plugin'},
+    );
+
+    $template->param( LoginBranchname    => $self->{session}->param('branchname') );
+
+    #if ( $in->{'template_name'} !~ m/maintenance/ ) {
+    #    ( $user, $cookie, $sessionID, $flags ) = checkauth(
+    #            $in->{'query'},
+    #            $in->{'authnotrequired'},
+    #            $in->{'flagsrequired'},
+    #            $in->{'type'}
+    #    );
+    #}
+
+    # TODO permissions
+
+    my $capabilities = {};
+    if (my $patron = Koha::Patrons->find( { userid => $userid } )) {
+        my $user_info = $patron->unblessed;
+        $template->param( "USER_INFO" => $user_info );
+        $capabilities = C4::Auth::getuserflags( $patron->flags, $userid );
+
+        my $borrowernumber = C4::Auth::getborrowernumber($userid);
+        $template->param( loggedinusername   => $userid );
+        $template->param( loggedinusernumber => $borrowernumber );
+
+        if ( $in->{'type'} eq 'opac' ) {
+            my $some_private_shelves = Koha::Virtualshelves->get_some_shelves( {
+                    borrowernumber => $borrowernumber,
+                    category       => 1,
+                    });
+            my $some_public_shelves = Koha::Virtualshelves->get_some_shelves( {
+                    category => 2,
+                    });
+            $template->param(
+                    some_private_shelves => $some_private_shelves,
+                    some_public_shelves  => $some_public_shelves,
+            );
+        }
+    }
+    elsif (my $id = $self->{session}->param('id')) { # admin? TODO verify
+        $capabilities = { superlibrarian => 1 };
+        $template->param( loggedinusername   => $id );
+    }
+    #warn Dumper($capabilities)." FLAGS";
+
+    my $all_perms = get_all_permissions();
+    for my $name (keys %$all_perms ) {
+        my $value = $capabilities->{superlibrarian} ? 1 : $capabilities->{$name};
+        $value //= 0;
+        #warn "$name => $value";
+        next unless $value;
+
+# expand a true value to a list of submodules;
+        $value = $all_perms->{$name} unless ref $value;
+
+        $template->param( "CAN_user_${name}" => 1 );
+        $template->param( "CAN_user_management" => 1 ) if $name eq 'parameters';
+        for my $subname ( keys %$value ) {
+            $template->param( "CAN_user_${name}_${subname}" => 1 );
+        }
+    }
+
+    return $template;
+}
+
+package Koha::Auth::Simple;
+use Data::Dumper;
+
+sub auth {
+    my ( $self, $session, $query ) = @_;
+    my $password = $query->param('password') or return;
+    my $userid = $query->param('userid') or die "password, but no userid?";
+
+    my ( $return, $cardnumber, $retuserid ) =
+      C4::Auth::checkpw_internal( C4::Context->dbh, $userid, $password, 1 );
+
+    if ( $return == 0 ) {    # FAIL
+        C4::Context->_unset_userenv( $session->id ); # I don't think this is needed
+        die "invalid login/password"; # TODO error management?
+        #$self->{info}->{invalid_username_or_password}++;
+    }
+    elsif ( $return == 2 ) {    # admin
+        $session->param( number => 0 );
+        $session->param( $_     => C4::Context->config('user') ) for qw/id cardnumber firstname surname/;
+        $session->param( branch     => 'NO_LIBRARY_SET' );
+        $session->param( branchname => 'NO_LIBRARY_SET' );
+        $session->param( flags      => 1 );
+        $session->param( emailaddress => C4::Context->preference('KohaAdminEmailAddress') );
+        $session->param( lasttime   => time() );
+        $session->param( shibboleth => 0 );
+    }
+    else {
+        $session->param( userid => $retuserid );
+        my $patron = Koha::Patrons->find( { userid => $retuserid } ) or die "can't find patron with userid: '$retuserid'";
+        $patron->track_login;
+        $session->param( cardnumber => $cardnumber );
+        $session->param( $_         => $patron->$_ ) for (qw/borrowernumber cardnumber firstname surname flags email/);
+        $session->param(id => $userid);
+        $session->param(branch       => $patron->branchcode );
+        $session->param(emailaddress => $patron->email );
+        #warn Dumper("user now logged in", $session);
+    }
+    return $retuserid;
+}
+
+package Koha::Auth::CAS;
+
+sub auth {
+    my ($self, $session, $query) = @_;
+
+    return 0;
+}
+
+package Koha::Auth::LDAP;
+
+sub auth {
+    my ($self, $session, $query) = @_;
+
+    return 0;
+}
+
+1;
diff --git a/Koha/Middleware/App.pm b/Koha/Middleware/App.pm
new file mode 100644
index 0000000..e89c650
--- /dev/null
+++ b/Koha/Middleware/App.pm
@@ -0,0 +1,180 @@
+use strict;
+use warnings;
+
+package Koha::Middleware::App;
+use base 'Plack::App::File';
+use Data::Dumper;
+use IO::Pipe;
+use JSON; our $JSON = JSON->new()->utf8(1);
+
+our ($out, $headers, $err);
+
+sub cgi_subprocess {
+    my ($self, $env, $file) = @_;
+    my $session = $env->{SESSION};
+    my $req     = Plack::Request->new($env);
+
+    no warnings;
+    local *CGI::new = sub {
+        return Koha::Middleware::Session::Mock->new(
+            param => sub {
+                $req->param(@_);
+            },
+            remote_user => sub {
+                $session->param('userid');
+            },
+            header => sub {
+                my ($h) = @_;
+                $h = {@_} unless 'HASH' eq ref $h;
+                my %t = (qw[
+                    type Content-Type
+                    -type Content-Type
+                    -charset Content-Charset
+                ]);
+                while ( my ( $s, $d ) = each %t ) {
+                    next unless exists $h->{$s};
+                    next if exists $h->{$d};
+                    $h->{$d} = $h->{$s};
+                    delete $h->{$s};
+                }
+                $headers->{$_} = $h->{$_} for keys %$h;
+            },
+            Vars => sub {
+                $req->parameters();
+            },
+            request_method => sub {
+                $req->method();
+            },
+            cookie => sub {
+                my ($name) = @_;
+                $req->cookies->{$name};
+            },
+            upload => sub {
+                my ($name) = @_;
+                my $file = $req->uploads->{$name};
+                return unless $file;
+                die "NIY";
+            },
+            multi_param => sub {
+                my ($name) = @_;
+                $req->parameters->get_all($name);
+            },
+            redirect => sub {
+                my ($url) = @_;
+                $headers->{Location} = $url;
+            },
+        );
+    };
+    use warnings;
+
+    local *STDOUT;
+    open STDOUT, '>', \$out or die "can't redirect stdout: $!";
+    warn "exec $file";
+
+    require $file;
+}
+
+sub slurp($) {
+    my ($fh) = @_;
+    local $/;
+    return <$fh>;
+}
+
+sub cgi_emulation {
+    my ($self, $env, $file) = @_;
+
+    my $pipe = IO::Pipe->new();
+    my $pid = fork() // die "can't fork: $!";
+
+    if (0==$pid) { # CHILD
+        $pipe->writer;
+
+        # scripts might exit(), and there is no way to prevent that without changing the script behavior
+        # so instead, let it exit, but first send the data back to the parent
+        # (note: this might now work with END {} blocks)
+        local $out = '';
+        local $headers = {};
+        local $err;
+        no warnings;
+        my $child_pid = $$;
+        local *CORE::GLOBAL::exit = sub {
+            my $exitcode = shift // 0;
+
+            # NOTE some scripts might fork (e.g.: tools/stage-marc-import.pl)
+            # in this case, the child WILL exit, and it WILL get here
+            # to avoid potential issues, i'll only "pipe" back from the main child
+            if ($child_pid == $$) {
+                eval {
+                    $pipe->print($JSON->encode([$out, $headers, $err]));
+                    $pipe->close;
+                    1;
+                } or warn $@;
+            }
+            CORE::exit($exitcode);
+        };
+        use warnings;
+
+        eval {
+            $self->cgi_subprocess($env, $file);
+            1;
+        } or do {
+            $err = "$@";
+            warn $@;
+        };
+        exit;
+    }
+
+    # PARENT
+    $pipe->reader;
+
+    my $data = '';
+    {
+        local $/;
+        my $exit = 0;
+        local $/ = undef;
+        while(!$pipe->eof) {
+            $_ = <$pipe>;
+            $data .= $_;
+        }
+        waitpid($pid, 0);
+    }
+
+    #warn "decoding($data)";
+    my ($out, $headers, $err) = do {
+        local $_;
+        eval {
+            $_ = $JSON->decode($data);
+            1;
+        } or die "Can't decode from child: '$data'";
+        @$_;
+    };
+
+    my $code = 200;
+    if (length $err) {
+        $err =~ m{^(\d\d\d)\s} and $code = $1;
+        $code = 500 if $code < 400 or $code >= 1000;
+        return [$code => [] => [$err]];
+    }
+
+    $code = 307 if $headers->{Location} and $code < 300;
+
+    return [$code => [%$headers] => [$out]];
+
+}
+
+sub call {
+    my ( $self, $env ) = @_;
+
+    my ( $file, $path_info ) = $self->locate_file($env);
+    $file or die "404 Not Found";
+
+    #warn "APP[$file] with $env->{SESSION}";
+    Koha::Caches->flush_L1_caches();
+    Koha::Cache::Memory::Lite->flush();
+
+    my $out = $self->cgi_emulation($env, $file);
+
+    return $out;
+}
+
+1;
diff --git a/Koha/Middleware/Session.pm b/Koha/Middleware/Session.pm
new file mode 100644
index 0000000..0cff5e3
--- /dev/null
+++ b/Koha/Middleware/Session.pm
@@ -0,0 +1,169 @@
+use strict;
+use warnings;
+
+package Koha::Middleware::Session;
+use parent qw(Plack::Middleware);
+
+use Time::HiRes;
+use Plack::Request;
+use Plack::Util;
+use Data::Dumper;
+
+use Koha::Session;
+use Koha::Auth;
+
+our $SESSION_CLASS = "Koha::Session::DB";
+#our $SESSION_CLASS = "Koha::Session::KohaCache";
+#our $SESSION_CLASS = "Koha::Session::Memory";
+
+=head1 NAME
+
+=head1 SYNOPSIS
+
+
+=head1 DESCRIPTION
+
+=cut
+
+sub bake_cookie {
+    my ($name,%args) = @_;
+    $name = URI::Escape::uri_escape($name) if $name =~ m{[^a-zA-Z\-\._~]};
+    my $value = $args{value}//'';
+    $value = URI::Escape::uri_escape($value) if $value =~ m{[^a-zA-Z\-\._~]};
+    my @out = "$name=$value";
+    $args{path}//='/';
+
+    for my $k (qw/domain path expires max-age/) {
+        next unless exists $args{$k};
+        my $v = $args{$k};
+        if (defined $v) {
+            #$v = URI::Escape::uri_escape($v) if $v =~ m{[^a-zA-Z\-\._~]};
+            push @out, "$k=$v";
+        } else {
+            push @out, "$k";
+        }
+    }
+    push @out, 'secure' if exists $args{secure};
+    push @out, 'HttpOnly' if exists $args{HttpOnly};
+
+    return join '; ', @out;
+}
+
+
+our $auth;
+our $session;
+our $req;
+
+sub call {
+    my ( $self, $env ) = @_;
+
+    # preemptively flush caches
+    Koha::Caches->flush_L1_caches();
+    Koha::Cache::Memory::Lite->flush();
+    C4::Context->_new_userenv(0);
+
+    local $req = Plack::Request->new($env);
+
+    my $sessionID = $req->cookies->{"koha.session"};
+    local $session = $env->{SESSION} = $SESSION_CLASS->new($sessionID, remote_addr => $req->address);
+
+    # TODO ip security
+
+    local $auth = Koha::Auth->new($session, $req);
+    my $out = $auth->auth($session, $req);
+
+    if (ref $out) { # auth returns a special response
+        eval { $out = $out->finalize(); };
+        return $out;
+    }
+
+    no warnings;
+    local *{C4::Auth::_get_template_and_user} = sub {
+        my ($args) = @_;
+        my $template = $auth->template_and_permissions($args);
+        return ($template,
+            $session->param('borrowernumber'),
+            undef, # cookies should not be carried around this way
+            $args->{flagsrequired}, # probably unused
+        );
+    };
+    local *{C4::Auth::_get_session} = sub { $session };
+    local *{C4::Auth::_check_cookie_auth} = sub {
+        return "failed" unless $session->param('userid');
+        ok => undef => 1;
+    };
+    use warnings;
+
+    my $t0 = Time::HiRes::time();
+    $out = eval { $self->app->($env); } || do {
+        my $error = "$@";
+        warn $error;
+        my $res = $req->new_response(500);
+        $res->body($error);
+        $res->finalize();
+    };
+    my $dt = Time::HiRes::time() - $t0;
+
+    printf STDERR "%s [%d] [%s %s] %s %.2f %s\n",
+        scalar(gmtime),
+        $$,
+        ($session->id//'-'),
+        ($session->param('userid')//'-'),
+        $req->path,
+        $dt,
+        $out->[0];
+
+    return Plack::Util::response_cb($out, sub {
+        my ($res) = @_;
+        my $cookie = bake_cookie('koha.session' =>
+            value => $session->id,
+            # secure?
+        );
+        Plack::Util::header_push($res->[1], 'Set-Cookie', $cookie);
+    });
+}
+
+#sub param {
+#    my ($self, $name) = @_;
+#    $self->{___req}->param($name);
+#}
+
+sub modern {
+    my ($req) = @_;
+    my $script = $req->path;
+    $script =~ s{^/intranet}{};
+    my $modname = "Web/$script"; $modname =~ s{(\.pl|)$}{}; $modname =~ s{/+}{::}g;
+    my $file = "Web/$script"; $file =~ s{(\.pl|)$}{.pm}; $modname =~ s{/+}{/}g;
+    eval { require $file; 1; } and return $modname;
+    return;
+}
+
+=head1 AUTHOR
+
+Francesco Rivetti, E<lt>oha@oha.itE<gt>
+
+=cut
+
+package Koha::Middleware::Session::Mock;
+use Data::Dumper;
+our $AUTOLOAD;
+
+sub new {
+    my ($type, %args) = @_;
+    bless {%args}, $type;
+}
+
+sub AUTOLOAD {
+    my ($self, @ARGS) = @_;
+    my $name = $AUTOLOAD;
+    while(length $name) {
+        my $code = $self->{$name} or next;
+        ref($code) eq 'CODE' or next;
+        return $code->(@ARGS);
+    } continue {
+        $name =~ s{^[^:]+::}{} or last;
+    }
+    Carp::confess "unknown method: $AUTOLOAD  => ".Dumper($self, @ARGS);
+}
+
+1;
diff --git a/Koha/Session.pm b/Koha/Session.pm
new file mode 100644
index 0000000..8b525d7
--- /dev/null
+++ b/Koha/Session.pm
@@ -0,0 +1,167 @@
+use strict;
+use warnings;
+
+package Koha::Session;
+use Data::Dumper;
+use Scalar::Util qw/refaddr/;
+use Carp qw/cluck/;
+
+sub new {
+    my ($type, $id, %args) = @_;
+    my $self = bless {
+        %args,
+        id => $id,
+        data => {},
+        rnd => rand(),
+    }, $type;
+    $self->_load();
+    return $self;
+}
+
+sub id {
+    my ($self) = @_;
+    return $self->{id};
+}
+
+sub remote_addr {
+    my ($self) = @_;
+    return $self->{remote_addr};
+}
+
+sub get {
+    my ($self, $key) = @_;
+    return $self->{data}->{$key};
+}
+
+sub put {
+    my ($self, $key, $val) = @_;
+    #warn Dumper({key=>$key,val=>$val,old=>$self->{data}->{$key}})." SESSION->put()";
+    $self->{data}->{$key} = $val;
+    $self->_save();
+}
+
+sub clear {
+    my ($self, @keys) = @_;
+    if (@keys) {
+        delete $self->{data}->{$_} for @keys;
+    } else {
+        $self->{data} = {};
+    }
+    $self->_save();
+}
+
+# legacy
+sub param {
+    my ($self, $key, @val) = @_;
+    my $old = $self->get($key);
+    if (@val) {
+        $self->put($key, @val);
+    }
+    return $old;
+}
+
+sub _gen_id {
+    return join '.', time(), $$, refaddr($_[0]);
+}
+
+sub _load { die "NIY"; }
+
+package Koha::Session::Memory;
+use base 'Koha::Session';
+use JSON; our $JSON = JSON->new()->utf8(1);
+
+our %STORAGE;
+
+sub _load {
+    my ($self) = @_;
+    my $id = $self->{id} //= $self->_gen_id();
+    my $data = $JSON->decode($STORAGE{$id}//'{}');
+    $self->{$_} = $data->{$_} for keys %$data;
+}
+
+sub _save {
+    my ($self) = @_;
+    my %data = %$self;
+    $STORAGE{$self->id} = $JSON->encode(\%data);
+}
+
+package Koha::Session::DB;
+use base 'Koha::Session';
+use Data::Dumper;
+use JSON; our $JSON = JSON->new()->utf8(0);
+
+sub _load {
+    my ($self) = @_;
+    my $id = $self->{id} //= $self->_gen_id();
+
+    my $dbh = C4::Context->dbh;
+    my $sth = $dbh->prepare("SELECT a_session AS data FROM sessions WHERE id = ?");
+    $sth->execute($id);
+    if (my $row = $sth->fetchrow_hashref()) {
+        my $data = $JSON->decode($row->{data}//'{}');
+        $self->{$_} = $data->{$_} for keys %$data;
+        #warn __PACKAGE__."->_load(".Dumper($self).")";
+    } else {
+        #warn __PACKAGE__."->_load(EMPTY => ".Dumper($self).")";
+    }
+}
+
+sub _save {
+    my ($self) = @_;
+    my %data = %$self;
+    $data{last_save} = Time::HiRes::time();
+
+    my $dbh = C4::Context->dbh;
+
+    my $sth = $dbh->prepare("SELECT a_session AS data FROM sessions WHERE id = ?");
+    $sth->execute($self->{id});
+    if (my $row = $sth->fetchrow_hashref()) {
+        my $old = $JSON->decode($row->{data}//'{}');
+
+        # TODO move this to a table column
+        $self->{last_save} eq $old->{last_save} or warn "concurrency check failed";
+
+        $sth = $dbh->prepare("UPDATE sessions SET a_session = ? WHERE id = ?");
+        $sth->execute($JSON->encode(\%data), $self->{id});
+    } else {
+        $sth = $dbh->prepare("INSERT INTO sessions (a_session, id) VALUES (?,?)");
+        $sth->execute($JSON->encode(\%data), $self->{id}) or die "insert failed";
+    }
+    $self->{last_save} = $data{last_save};
+    #warn __PACKAGE__."->_save(".Dumper($self).")";
+}
+
+package Koha::Session::KohaCache;
+use base 'Koha::Session';
+use Data::Dumper;
+
+use Koha::Cache;
+our $C;
+
+sub _init {
+    my ($self) = @_;
+    $C = Koha::Cache->new(
+        {
+            cache_type => 'memcached',
+        }, {
+            subnamespace => 'plack.session',
+        },
+    );
+}
+
+sub _load {
+    my ($self) = @_;
+    $C//=_init();
+    my $id = $self->{id} //= $self->_gen_id();
+    my $data = $C->get_from_cache($id);
+    $self->{$_} = $data->{$_} for keys %$data;
+    warn Dumper($self)." FROM KohaCache";
+}
+
+sub _save {
+    my ($self) = @_;
+    $C//=_init();
+    $C->set_in_cache($self->{id}, $self);
+}
+
+1;
diff --git a/debian/templates/plack.psgi b/debian/templates/plack.psgi
index 8b9b7be..b5d764c 100644
--- a/debian/templates/plack.psgi
+++ b/debian/templates/plack.psgi
@@ -59,6 +59,16 @@ my $opac = Plack::App::CGIBin->new(
     root => $ENV{DEV_INSTALL}? "$home/opac": "$home/opac/cgi-bin/opac"
 )->to_app;

+#Uncomment to enable Koha Session Middleware
+#use Koha::Middleware::App;
+#my $intranet = Koha::Middleware::App->new(
+#    root => '/usr/share/koha/intranet/cgi-bin'
+#)->to_app;
+#
+#my $opac = Koha::Middleware::App->new(
+#    root => '/usr/share/koha/opac/cgi-bin/opac'
+#)->to_app;
+
 my $apiv1  = builder {
     my $server = Mojo::Server::PSGI->new;
     $server->load_app("$home/api/v1/app.pl");
@@ -70,6 +80,7 @@ builder {
     enable "Plack::Middleware::Static";
     # + is required so Plack doesn't try to prefix Plack::Middleware::
     enable "+Koha::Middleware::SetEnv";
+    #enable "+Koha::Middleware::Session";

     mount '/opac'          => $opac;
     mount '/intranet'      => $intranet;
--- /dev/null
+++ b/t/auth/10-session.t
@@ -0,0 +1,47 @@
+use strict;
+use warnings;
+
+use Test::More;
+use Data::Dumper;
+
+require_ok('Koha::Session');
+
+my $id;
+{
+    my $s = Koha::Session::Memory->new();
+    ok($s, 'new');
+    ok($id=$s->id, 'id');
+    like($s->id, qr/\w{6}/, 'id val');
+
+    ok(!$s->get('foo'), 'no foo');
+    $s->put(foo => $$),
+    $s->put(bar => $$+10);
+    is($s->get('foo'), $$, 'foo set');
+    is($s->get('bar'), $$+10, 'bar set');
+
+    $s->put(bar => $$+20);
+    is($s->get('bar'), $$+20, 'bar updated');
+
+    $s->put(complex => { data => [qw/ h e r e /] });
+    is($s->get('complex')->{data}->[2], 'r', 'complex');
+}
+
+{
+    my $s = Koha::Session::Memory->new($id);
+    ok($s, '_load');
+    is($s->id, $id, 'same id');
+    is($s->get('foo'), $$, 'same foo');
+    is($s->get('bar'), $$+20, 'same bar');
+    is($s->get('complex')->{data}->[2], 'r', 'same complex');
+
+    $s->clear();
+    ok(!$s->get('foo'), 'cleared foo');
+}
+
+{
+    my $s = Koha::Session::Memory->new($id);
+    ok(!$s->get('bar'), 'persistently cleared bar');
+}
+
+
+done_testing();
diff --git a/t/auth/20-auth.t b/t/auth/20-auth.t
new file mode 100644
index 0000000..edb287a
--- /dev/null
+++ b/t/auth/20-auth.t
@@ -0,0 +1,61 @@
+use strict;
+use warnings;
+
+use Test::More;
+use Data::Dumper;
+use t::lib::Mocks;
+
+use Koha::Session;
+use C4::Members;
+use Carp::Always;
+
+use t::lib::TestBuilder;
+use Koha::AuthUtils;
+
+use_ok('Koha::Auth');
+
+my $session = Koha::Session::Memory->new();
+ok($session, 'session');
+
+my %query = (
+    #'logout.x'
+);
+my $query = t::lib::Mocks::Mock->new(
+    param => sub {
+        my ($self, $name) = @_;
+        return $query{$name};
+    },
+);
+
+# init
+my $builder = t::lib::TestBuilder->new;
+my $adam = $builder->build({ source => 'Borrower', value => { password => Koha::AuthUtils::hash_password('test') }});
+
+# empty
+{
+    my $auth = Koha::Auth->new($session, $query);
+    $auth->auth();
+}
+
+# simple login
+{
+    local $query{userid} = $adam;
+    local $query{password} = 'test';
+    no warnings;
+    local *{C4::Auth::checkpw_internal} = sub {
+        return 1, $adam->{cardnumber}, $adam->{userid};
+    };
+    use warnings;
+
+    my $auth = Koha::Auth->new($session, $query);
+    $auth->auth();
+    is($session->get('userid'), $adam->{userid}, 'logged userid');
+    is($session->get('cardnumber'), $adam->{cardnumber}, 'logged cardnumber');
+
+    # legacy
+    my $userenv = C4::Context->userenv;
+    is($userenv->{cardnumber}, $adam->{cardnumber}, 'C4::Context cardnumber');
+    is($userenv->{id}, $adam->{userid}, 'C4::Context id (userid)');
+}
+
+done_testing();
diff --git a/t/lib/Mocks.pm b/t/lib/Mocks.pm
index 46a87cb..773a28c 100644
--- a/t/lib/Mocks.pm
+++ b/t/lib/Mocks.pm
@@ -50,4 +50,29 @@ sub mock_dbh {
     return $context;
 }

+package t::lib::Mocks::Mock;
+use Data::Dumper;
+
+sub new {
+    my ($type, %hooks) = @_;
+    my $self = bless {
+        '' => \%hooks,
+    }, $type;
+}
+
+our $AUTOLOAD;
+sub AUTOLOAD {
+    my ( $self, @ARGS ) = @_;
+    my $name = $AUTOLOAD;
+    while ( length $name ) {
+        my $code = $self->{''}->{$name} or next;
+        ref($code) eq 'CODE' or next;
+        return $code->( $self, @ARGS );
+    }
+    continue {
+        $name =~ s{^[^:]+::}{} or last;
+    }
+    Carp::confess( "unknown method: $AUTOLOAD  => " . Dumper( $self, @ARGS ) . " ..." );
+}
+
 1;
